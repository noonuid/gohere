package problem0010

// 10. 正则表达式匹配

// 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

// '.' 匹配任意单个字符
// '*' 匹配零个或多个前面的那一个元素

// 所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。

// 动态规划。
func isMatch(s string, p string) bool {
	lenS, lenP := len(s), len(p)
	// f[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否可以匹配。
	f := make([][]bool, lenS+1)
	for i := 0; i < lenS+1; i++ {
		f[i] = make([]bool, lenP+1)
	}
	f[0][0] = true
	for i := 0; i < lenS+1; i++ {
		for j := 1; j < lenP+1; j++ {
			if p[j-1] != '*' {
				// p 中第 n 个字符为 a-z 或者 ‘.’。

				if i > 0 && (s[i-1] == p[j-1] || p[j-1] == '.') {
					// 若 s 的第 i 个字符和 p 的第 j 个字符相等，或者 p 的第 j 个字符为 ‘.’，
					// 则位置 i 与 位置 j 能够匹配，f[i][j] = f[i-1][j-1]。

					f[i][j] = f[i-1][j-1]
				}
			} else {
				// p 中第 n 个字符为 ‘*’。
				// 将与其前一个字符看作一个组合，该组合在匹配过程中有两种情况：
				// 1、匹配 s 末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配（即匹配一个或多个字符），f[i][j] = f[i-1][j]。
				// 2、不匹配字符，将该组合扔掉，不再进行匹配（即匹配 0 个字符），f[i][j] = f[i][j-2]。

				if i > 0 && (s[i-1] == p[j-2] || p[j-2] == '.') {
					// 当 s 的第 i 个字符和 p 的第 j-1 个字符（‘*’前的字符）能够匹配时，
					// 可以使用该组合匹配一个或多个字符，也可以匹配 0 个字符。
					f[i][j] = f[i-1][j] || f[i][j-2]
				} else {
					// 当 s 的第 i 个字符和 p 的第 j-1 个字符（‘*’前的字符）不能够匹配时，
					// 该组合只能匹配 0 个字符。
					f[i][j] = f[i][j-2]
				}
			}
		}
	}
	return f[lenS][lenP]
}
